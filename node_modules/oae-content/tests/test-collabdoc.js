/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');

var ContentDAO = require('oae-content/lib/internal/dao');
var RestAPI = require('oae-rest');
var SearchTestsUtil = require('oae-search/lib/test/util');
var TestsUtil = require('oae-tests');

var Etherpad = require('oae-content/lib/internal/etherpad');

describe('Collaboration documents', function() {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousRestContext = null;
    // Rest context that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;

    var multipleServers = {
        'hosts': [
            {
                'apikey': '13SirapH8t3kxUh5T5aqWXhXahMzoZRA',
                'protocol': 'https',
                'host': '0.etherpad.oae.com',
                'port': 80
            },
            {
                'apikey': '13SirapH8t3kxUh5T5aqWXhXahMzoZRA',
                'protocol': 'https',
                'host': '1.etherpad.oae.com',
                'port': 80
            }
        ]
    };
    var testConfig = null;

    /**
     * Function that will fill up the anonymous and tenant admin REST context
     */
    before(function(callback) {
        // Fill up anonymous rest context
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Fill up tenant admin rest contexts
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        // Get the original test config.
        testConfig = Etherpad.getConfig();
        callback();
    });

    /**
     * Verifies that the load is balanced based on the content ID.
     */
    it('verify different servers get selected depending on the content ID', function() {
        // Configure Etherpad with 2 servers, rather than the default 1.
        Etherpad.refreshConfiguration(multipleServers);

        var hostA = Etherpad.getServerBaseURL('c:cam:abc123');
        var hostB = Etherpad.getServerBaseURL('c:cam:abc1231');
        assert.notEqual(hostA, hostB);

        // Re-configure Etherpad with the defaults.
        Etherpad.refreshConfiguration(testConfig);
    });

    /**
     * Verifies that you can only join a collaborative document if you have viewer permissions
     */
    it('verify joining a pad respects the content permissions.', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;
            var brandenCtx = _.values(users)[1].restContext;

            // Simon creates a collaborative document that's private.
            var name = TestsUtil.generateTestUserId();
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err);

                RestAPI.Content.joinCollabDoc(simonCtx, contentObj.id, function(err, data) {
                    assert.ok(!err);
                    assert.ok(data);

                    // Branden has no access yet, so this should be a 401
                    RestAPI.Content.joinCollabDoc(brandenCtx, contentObj.id, function(err, data) {
                        assert.equal(err.code, 401);
                        assert.ok(!data);

                        // Share it with branden.
                        var members = {};
                        members[_.keys(users)[1]] = 'viewer';
                        RestAPI.Content.updateMembers(simonCtx, contentObj.id, members, function(err) {
                            assert.ok(!err);

                            // Branden should now be able to access it.
                            RestAPI.Content.joinCollabDoc(simonCtx, contentObj.id, function(err, data) {
                                assert.ok(!err);
                                assert.ok(data);
                                callback();
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that you can only publish a collaborative document if you have manager permissions
     */
    it('verify publishing a pad respects the content permissions.', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;
            var brandenCtx = _.values(users)[1].restContext;

            // Simon creates a collaborative document that's private.
            var name = TestsUtil.generateTestUserId();
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err);

                RestAPI.Content.publishCollabDoc(simonCtx, contentObj.id, function(err, data) {
                    assert.ok(!err);
                    assert.ok(data);

                    // Branden has no access yet, so this should be a 401
                    RestAPI.Content.publishCollabDoc(brandenCtx, contentObj.id, function(err, data) {
                        assert.equal(err.code, 401);
                        assert.ok(!data);

                        // Share it with branden.
                        var members = {};
                        members[_.keys(users)[1]] = 'manager';
                        RestAPI.Content.updateMembers(simonCtx, contentObj.id, members, function(err) {
                            assert.ok(!err);

                            // Branden should now be able to access it.
                            RestAPI.Content.publishCollabDoc(simonCtx, contentObj.id, function(err, data) {
                                assert.ok(!err);
                                assert.ok(data);

                                // By now we should have 3 revisions (not 4, as Branden's first publish was unauthorized)
                                RestAPI.Content.getRevisions(simonCtx, contentObj.id, null, null, function(err, revisions) {
                                    assert.ok(!err);
                                    assert.equal(revisions.length, 3);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Set some text in Etherpad.
     *
     * @param  {Content}    contentObj      The content object for which we should update the etherpad text.
     * @param  {String}     text            The text to place in the pad.
     * @param  {Function}   callback        Standard callback method.
     * @param  {Object}     callback.err    Error object, if any.
     */
    var setEtherpadText = function(contentObj, text, callback) {
        var etherpadClient = Etherpad.getClient(contentObj.id);
        var args = {
            'padID': contentObj.collabdoc.padID,
            'text': text
        };
        etherpadClient.setText(args, callback);
    };

    /**
     * Get the text that is stored in Etherpad.
     *
     * @param  {Content}    contentObj          The content object for which we should retrieve the etherpad text.
     * @param  {Function}   callback            Standard callback method.
     * @param  {Object}     callback.err        Error object, if any.
     * @param  {Object}     callback.data       Standard Etherpad API response object.
     * @param  {String}     callback.data.text  The actual string of text that is stored in the pad.
     */
    var getEtherpadText = function(contentObj, callback) {
        var etherpadClient = Etherpad.getClient(contentObj.id);
        var args = {
            'padID': contentObj.collabdoc.padID
        };
        etherpadClient.getText(args, callback);
    };

    /**
     * Changes the text in the etherpad pad and publishes the document.
     * The amount of edit/publish cycles depends on how many strings there are in the `texts` array.
     * Each string will be placed in the pad and result in a document publish.
     *
     * @param  {Context}    context     The request context to use for publishing the document.
     * @param  {Content}    contentObj  The content object to publish
     * @param  {String[]}   texts       An array of texts that should be placed in the pad. The document will be published for each string in this array.
     * @param  {Function}   callback    Standard callback method.
     */
    var editAndPublish = function(context, contentObj, texts, callback) {
        var done = 0;

        var doEditAndPublish = function() {
            if (done === texts.length) {
                return callback();
            }

            // Do some edits in etherpad.
            setEtherpadText(contentObj, texts[done], function(err) {
                assert.ok(!err);

                RestAPI.Content.publishCollabDoc(context, contentObj.id, function(err, data) {
                    assert.ok(!err);
                    assert.ok(data);
                    done++;
                    doEditAndPublish();
                });
            });
        };
        doEditAndPublish();
    };

    /**
     * This test verifies that the latest HTML is retrieved when publishing a collaboration document
     * It does this by creating a pad, submitting some text in etherpad, publishing the document, retrieving the new content object
     * from our API and verifying the new text is there.
     * It also performs some more etherpad edits and verifies these do not get streamed to our API.
     */
    it('verify the correct HTML is retrieved when publishing.', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;

            // Simon creates a collaborative document that's private.
            var name = TestsUtil.generateTestUserId();
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err);

                // Verify there is no HTML present yet.
                RestAPI.Content.getContent(simonCtx, contentObj.id, function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(!contentObj.collabdoc.html);

                    // Do some edits in etherpad.
                    var text = 'Only two things are infinite, the universe and human stupidity, and I am not sure about the former.';
                    editAndPublish(simonCtx, contentObj, [text], function() {

                        RestAPI.Content.getContent(simonCtx, contentObj.id, function(err, updatedContentObj) {
                            assert.ok(!err);
                            assert.ok(updatedContentObj.collabdoc.html);
                            assert.notEqual(updatedContentObj.collabdoc.html, contentObj.collabdoc.html);

                            // Remove linebreaks and check if the text is correct.
                            var html = updatedContentObj.collabdoc.html.replace('<br>', '');
                            assert.equal(html, text);

                            // If we make any further updates in etherpad they shouldn't show up yet from our API.
                            setEtherpadText(contentObj, 'There are no facts, only interpretations.', function(err) {
                                assert.ok(!err);

                                RestAPI.Content.getContent(simonCtx, contentObj.id, function(err, latestContentObj) {
                                    assert.ok(!err);
                                    assert.ok(latestContentObj.collabdoc.html);
                                    assert.equal(latestContentObj.collabdoc.html, updatedContentObj.collabdoc.html);
                                    callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that documents that are published, can be searched on.
     */
    it('verify that published collaboration documents are searchable', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;

            // Simon creates a collaborative document that's private.
            var name = TestsUtil.generateTestUserId('collabdoc');
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err, JSON.stringify(err, null, 4));

                RestAPI.Content.getContent(simonCtx, contentObj.id, function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(!contentObj.collabdoc.html);

                    // Do some edits in etherpad.
                    editAndPublish(simonCtx, contentObj, ['Most modern calendars mar the sweet simplicity of our lives by reminding us that each day that passes is the anniversary of some perfectly uninteresting event.'], function() {
                        SearchTestsUtil.searchAll(simonCtx, 'general', null, {'q': 'uninteresting event', 'resourceTypes': 'content'}, function(err, data) {
                            assert.ok(!err);
                            assert.equal(data.results.length, 1);
                            assert.equal(data.results[0].id, contentObj.id);
                            callback();
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that published documents can be restored.
     */
    it('verify that published collaboration documents are restorable', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;

            var name = TestsUtil.generateTestUserId('collabdoc');
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'private', [], [], function(err, contentObj) {
                assert.ok(!err, JSON.stringify(err, null, 4));

                RestAPI.Content.getContent(simonCtx, contentObj.id, function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(!contentObj.collabdoc.html);

                    var texts = [
                        'Always do sober what you said you\'d do drunk. That will teach you to keep your mouth shut.',
                        'Bill Gates is a very rich man today... and do you want to know why? The answer is one word: versions.',
                        'I don\'t have to play by these rules or do these things... I can actually have my own kind of version.'
                    ];
                    editAndPublish(simonCtx, contentObj, texts, function() {
                        RestAPI.Content.getRevisions(simonCtx, contentObj.id, null, null, function(err, revisions) {
                            assert.ok(!err);

                            // We published our document 3 times, this should result in 4 revisions. (1 create + 3 publications)
                            assert.equal(revisions.length, 4);

                            // Restore the second revision.
                            // The html on the content item and in etherpad should be updated.
                            RestAPI.Content.restoreRevision(simonCtx, contentObj.id, revisions[1].revisionId, function(err) {
                                assert.ok(!err, JSON.stringify(err, null, 4));

                                RestAPI.Content.getContent(simonCtx, contentObj.id, function(err, updatedContent) {
                                    assert.ok(!err);
                                    // Etherpad always adds a trailing <br> tag when fetching the text.
                                    assert.equal(updatedContent.collabdoc.html, texts[1] + '<br>');

                                    getEtherpadText(contentObj, function(err, data) {
                                        assert.ok(!err);
                                        assert.equal(data.text, texts[1] + '\n');
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });

    /**
     * Verifies that restoring collaborative documents is access scoped
     */
    it('verify that restoring collaborative documents is access scoped.', function(callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users) {
            assert.ok(!err);
            var simonCtx = _.values(users)[0].restContext;
            var brandenCtx = _.values(users)[1].restContext;

            var name = TestsUtil.generateTestUserId('collabdoc');
            RestAPI.Content.createCollabDoc(simonCtx, name, 'description', 'public', [], [], function(err, contentObj) {
                assert.ok(!err, JSON.stringify(err, null, 4));

                RestAPI.Content.getContent(simonCtx, contentObj.id, function(err, contentObj) {
                    assert.ok(!err);
                    assert.ok(!contentObj.collabdoc.html);

                    var texts = ['Any sufficiently advanced technology is indistinguishable from magic.'];
                    editAndPublish(simonCtx, contentObj, texts, function() {
                        RestAPI.Content.getRevisions(simonCtx, contentObj.id, null, null, function(err, revisions) {
                            assert.ok(!err);
                            assert.equal(revisions.length, 2);

                            // Restore the second revision.
                            // The html on the content item and in etherpad should be updated.
                            RestAPI.Content.restoreRevision(brandenCtx, contentObj.id, revisions[0].revisionId, function(err) {
                                assert.equal(err.code, 401);

                                // Branden creates his own content item so can use that contentId.
                                // It should still result in a 401.
                                RestAPI.Content.createLink(simonCtx, 'Test link', 'Description', 'public', 'http://www.google.com', [], [], function(err, brandenContent) {
                                    assert.ok(!err);
                                    RestAPI.Content.restoreRevision(brandenCtx, brandenContent.id, revisions[0].revisionId, function(err) {
                                        assert.equal(err.code, 401);
                                        callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
