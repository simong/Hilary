/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var clone = require('clone');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('PageTree');
var Validator = require('oae-util/lib/validator').Validator;

var PageTree = function(contentId, _hierarchy, _metadata) {
    var hierarchy = clone(_hierarchy);
    var metadata = clone(_metadata);

    var topNode = {
        'pid': null,
        'children': hierarchy
    };


    // The object that exposes the tree functionality.
    var that = {};

    /**
     * Returns the parent of the two nodes.
     *
     * @param  {[type]} node         [description]
     * @param  {[type]} afterPageId  [description]
     * @param  {[type]} beforePageId [description]
     * @return {[type]}              [description]
     */
    var findBetween = function(node, afterPageId, beforePageId) {
        // If we have to stick it in front,
        // we only need to look at the first node.
        if (afterPageId === null) {
            if (node.children.length > 0 && node.children[0].pid === beforePageId) {
                return node;
            }
        }

        // If we have to stick it at the end,
        // we only need to look at the last node.
        if (beforePageId === null) {
            if (node.children.length > 0 && node.children[node.children.length - 1].pid === afterPageId) {
                return node;
            }
        }

        // Try to find it in the children array.
        for (var i = 0; i < node.children.length - 1; i++) {
            // Check if this child node fits the description
            if (node.children[i].pid === afterPageId && node.children[i + 1].pid === beforePageId) {
                return node;
            // If it doesn't we recurse down.
            } else {
                var result = findBetween(node.children[i], afterPageId, beforePageId);
                if (result) {
                    return result;
                }
            }
        }

        // Look at the last child node on this level (if there are any).
        if (node.children.length > 0) {
            return findBetween(node.children[node.children.length - 1], afterPageId, beforePageId);
        } else {
            return false;
        }
    };

    /**
     * Checks if any of the children of the provided node match the passed in pageId.
     * This will return the **parent** of the looked for page.
     * @param  {[type]} node   [description]
     * @param  {[type]} pageId [description]
     * @return {[type]}        [description]
     */
    var findByPageId = function(node, pageId) {
        for (var i = 0; i < node.children.length; i++) {
            if (node.children[i].pid === pageId) {
                return {
                    'node': node,
                    'index': i
                };
            } else {
                var result = findByPageId(node.children[i], pageId);
                if (result) {
                    return result;
                }
            }
        }
        return false;
    };

    /**
     * Inserts a node in the tree.
     * @param {Node}        node            The node to inserver.
     * @param {String}      afterPageId     The ID of the page where the node should come immediately after. If the node should become the first page at a level, leave this null.
     * @param {String}      beforePageId    The ID of the page where the node should come immediately before. If the node should become the last page at a level, leave this null.
     * @param {Function}    callback        Standard callback method.
     * @param {Object}      callback.err    Standard error object (if any.)
     */
    var _insert = function(node, afterPageId, beforePageId, callback) {
        // Look for the parent node of where we want to insert the node.
        var parent = findBetween(topNode, afterPageId, beforePageId);
        if (!parent) {
            return callback({'code': 400, 'msg': 'Could not find a location for the provided page IDs.'});
        }

        // The new node needs to be added at the top (first).
        if (afterPageId === null) {
            parent.children.unshift(node);
            return that.save(callback);

        // The new node needs to be added at the bottom (end).
        } else if (afterPageId !== null && beforePageId === null) {
            parent.children.push(node);
            return that.save(callback);
        }

        // The new node needs to be added between two nodes.
        var index = 0;
        for (var i = 0; i < parent.children.length; i++) {
            if (parent.children[i].pid === afterPageId&& parent.children[i+1] && parent.children[i+1].pid === beforePageId) {
                index = i + 1;
                break;
            }
        }
        parent.children.splice(index, 0, node);
        callback();
    };


    /**
     * Saves the entire tree to Cassandra.
     *
     * @param {Function}    [callback]      Standard callback method.
     * @param {Object}      [callback.err]  Standard error object (if any.)
     */
    that.save = function(callback) {
        callback = callback || function(err) {
            if (err) {
                log.error({'err': err}, 'Something went wrong trying to save the page hierarchy for %s.', contentId);
            }
        };

        var values = clone(metadata);
        values.hierarchy = JSON.stringify(hierarchy);

        // We'll need to drop all the values in the row before we can re-create it.
        var queries = [];
        queries.push({'query': 'DELETE FROM PagesHierarchy WHERE contentId = ?', 'parameters': [contentId]});
        queries.push(Cassandra.constructUpsertCQL('PagesHierarchy', 'contentId', contentId, values));

        // Run it.
        Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    };

    /**
     * Add a page in the tree.
     *
     * @param {String}   pageId       The ID of the new page.
     * @param {String}   title        The title of the new page.
     * @param {Boolean}  isDraft      Whether or not this page is a draft.
     * @param {String}   afterPageId  The ID of the page where the new page should come immediately after. If the new page should become the first page at a level, leave this null.
     * @param {String}   beforePageId The ID of the page where the new page should come immediately before. If the new page should become the last page at a level, leave this null.
     * @param {Function} callback     Standard callback method.
     * @param {Object}   callback.err Standard error object (if any.)
     */
    that.add = function(pageId, title, isDraft, afterPageId, beforePageId, callback) {
        var validator = new Validator();
        validator.check(pageId, {'code': 400, 'msg': 'The new page ID is not valid.'}).isResourceId();
        validator.check(title, {'code': 400, 'msg': 'The title of the new page must be provided.'}).notNull();
        validator.check(isDraft, {'code': 400, 'msg': 'The draft status of the new page must be provided.'}).notNull();
        if (afterPageId) {
            validator.check(afterPageId, {'code': 400, 'msg': 'The afterPageId is not valid.'}).isResourceId();
            validator.check(metadata[afterPageId], {'code': 400, 'msg': 'The afterPageId could not be found in the tree.'}).notNull();
        }
        if (beforePageId) {
            validator.check(beforePageId, {'code': 400, 'msg': 'The beforePageId is not valid.'}).isResourceId();
            validator.check(metadata[beforePageId], {'code': 400, 'msg': 'The beforePageId could not be found in the tree.'}).notNull();
        }
        if (!afterPageId && !beforePageId) {
            validator.error({'code': 400, 'msg': 'At least one of afterPageId or beforePageId should be specified.'});
        }
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        // Insert the node in the tree
        var node = {'pid': pageId, 'children': []};
        _insert(node, afterPageId, beforePageId, function(err) {
            if (err) {
                return callback(err);
            }

            // Save the metadata:
            metadata[pageId] = title + '#' + isDraft;

            that.save(callback);
        });
    };


    /**
     * Moves a page to another location in the tree.
     * @param {String}      pageId          The ID of the page you wish to move.
     * @param {String}      afterPageId     The ID of the page where the page should come immediately after. If the page should become the first page at a level, leave this null.
     * @param {String}      beforePageId    The ID of the page where the new page should come immediately before. If the page should become the last page at a level, leave this null.
     * @param {Function}    callback        Standard callback method.
     * @param {Object}      callback.err    Standard error object (if any.)
     */
    that.move = function(pageId, afterPageId, beforePageId, callback) {
        var validator = new Validator();
        validator.check(pageId, {'code': 400, 'msg': 'The page ID is not valid.'}).isResourceId();
        validator.check(metadata[pageId], {'code': 400, 'msg': 'The page ID could not be found.'}).notNull();
        if (afterPageId) {
            validator.check(afterPageId, {'code': 400, 'msg': 'The afterPageId is not valid.'}).isResourceId();
            validator.check(metadata[afterPageId], {'code': 400, 'msg': 'The afterPageId could not be found in the tree.'}).notNull();
        }
        if (beforePageId) {
            validator.check(beforePageId, {'code': 400, 'msg': 'The beforePageId is not valid.'}).isResourceId();
            validator.check(metadata[beforePageId], {'code': 400, 'msg': 'The beforePageId could not be found in the tree.'}).notNull();
        }
        if (!afterPageId && !beforePageId) {
            validator.error({'code': 400, 'msg': 'At least one of afterPageId or beforePageId should be specified.'});
        }
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        var result = findByPageId(topNode, pageId);
        if (!result) {
            // This shouldn't strictly be possible.
            return callback({'code': 400, 'msg': 'Could not find a page with that ID'});
        }

        // Detach the node.
        var node = result.node.children[result.index];
        result.node.children.splice(result.index, 1);

        // re-insert it.
        _insert(node, afterPageId, beforePageId, function(err) {
            if (err) {
                return callback(err);
            }

            that.save(callback);
        });
    };



    /**
     * Removes a page from the tree.
     *
     * @param {String}   pageId         The ID of the page you wish to remove.
     * @param {Function} callback       Standard callback method.
     * @param {Object}   callback.err   Standard error object (if any.)
     */
    that.remove = function(pageId, callback) {
        var validator = new Validator();
        validator.check(pageId, {'code': 400, 'msg': 'The pageId is not valid.'}).isResourceId();
        validator.check(metadata[pageId], {'code': 400, 'msg': 'The pageId could not be found in the tree.'}).notNull();
        // Edge-case: Do not remove a top level node if it's the only one at the top.
        if (topNode.children.length === 1 && topNode.children[0].pid === pageId) {
            validator.error({'code': 400, 'msg': 'You cannot remove the only page that is left.'});
        }
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        var result = findByPageId(topNode, pageId);
        if (!result) {
            // This shouldn't strictly be possible.
            return callback({'code': 404, 'msg': 'Could not find a page with that ID'});
        }

        /**
         * Deletes the meta data for a node and all it's children.
         *
         * @param {Node} node The node to remove the meta data for.
         */
        var deleteMetaData = function(node) {
            // Delete the page from the meta data.
            delete metadata[node.pid];

            // Recurse over children.
            for (var i = 0; i < node.children.length; i++) {
                deleteMetaData(node.children[i]);
            }
        };

        deleteMetaData(result.node.children[result.index]);
        
        // Delete the node.
        result.node.children.splice(result.index, 1);

        // Save the tree.
        that.save(callback);
    };

    /**
     * Update the metadata of a page.
     *
     * @param {String}      pageId          The ID of the page you wish to update the metadata for.
     * @param {String}      title           The new title of the page.
     * @param {Boolean}     isDraft         Whether or not this page is a draft.
     * @param {Function}    callback        Standard callback method.
     * @param {Object}      callback.err    Standard error object (if any.)
     */
    that.updateMetaData = function(pageId, title, isDraft, callback) {
        var validator = new Validator();
        validator.check(pageId, {'code': 400, 'msg': 'The pageId is not valid.'}).isResourceId();
        validator.check(metadata[pageId], {'code': 400, 'msg': 'The pageId could not be found in the tree.'}).notNull();
        validator.check(title, {'code': 400, 'msg': 'The title of the page must be provided.'}).notNull();
        validator.check(title, {'code': 400, 'msg': 'The title of the page cannot contain a hash sign.'}).notContains('#');
        validator.check(isDraft, {'code': 400, 'msg': 'The draft status of the page must be provided.'}).notNull();
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        // Update the metadata directly, this is much safer and cheaper than calling .save()
        var values = {};
        values[pageId] = title + '#' + isDraft;
        var q = Cassandra.constructUpsertCQL('PagesHierarchy', 'contentId', contentId, values, 'QUORUM');
        Cassandra.runQuery(q.query, q.parameters, callback);
    };

    /**
     * @return {Object} A hash where each key is a page ID and the value is an object with a title and isDraft status.
     */
    that.getMetaData = function() {
        var data = {};
        var pages = Object.keys(metadata);
        for (var i = 0; i < pages.length; i++) {
            var m = metadata[pages[i]].split('#');
            data[pages[i]] = {
                'title': m[0],
                'isDraft': m[1]
            };
        }
        return data;
    };

    /**
     * @return {Object} A simple tree structure that represents the pages.
     */
    that.getHierarchy = function() {
        return clone(hierarchy);
    };

    return that;
};

/**
 * Get a PageTree.
 *
 * @param {Context}     ctx             Standard execution context representing the current tenant and logged in user.
 * @param {String}      contentId       The content ID for which the tree should be retrieved.
 * @param {Function}    callback        Standard callback method.
 * @param {Object}      callback.err    Standard error object (if any.)
 * @param {PageTree}    callback.tree   The tree that's associated to this content ID.
 */
module.exports.getTree = function(ctx, contentId, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'The provided content ID is not valid.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    Cassandra.runQuery('SELECT * FROM PagesHierarchy where contentId = ?', [contentId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].ColumnCount <= 1) {
            return callback({'code': 404, 'msg': 'Could not find a tree for that ID.'});
        }
        
        var metadata = Cassandra.rowToHash(rows[0]);
        var hierarchy = JSON.parse(metadata.hierarchy);
        delete metadata.hierarchy;
        delete metadata.contentId;

        var tree = new PageTree(contentId, hierarchy, metadata);
        callback(null, tree);
    });
};

/**
 * Create a new tree. An initial page must be provided.
 * It's up to the caller to perform a `save` action.
 *
 * @param {Context}     ctx             Standard execution context representing the current tenant and logged in user.
 * @param {String}      contentId       The content ID for which the tree should be created.
 * @param {String}      pageId          The page ID of the initial page.
 * @param {String}      pageTitle       The title of the initial page.
 * @param {Boolean}     isDraft         Whether or not this page is a draft.
 * @param {Function}    callback        Standard callback method.
 * @param {Object}      callback.err    Standard error object (if any)
 * @param {PageTree}    callback.tree   The tree object. If you want this tree to be persisted, you'll need to call `tree.save()`.
 */
module.exports.createTree = function(ctx, contentId, pageId, pageTitle, isDraft, callback) {
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'The provided content ID is not valid.'}).isResourceId();
    validator.check(pageId, {'code': 400, 'msg': 'The provided page ID is not valid.'}).isResourceId();
    validator.check(pageTitle, {'code': 400, 'msg': 'A title must be provided'}).isNotNull();
    validator.check(isDraft, {'code': 400, 'msg': 'The isDraft flag must be either true or false'}).isBoolean();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var hierarchy = [{
        'pid': pageId,
        'children': []
    }];

    var metadata = {};
    metadata[pageId] = pageTitle + '#' + isDraft;

    var tree = new PageTree(contentId, hierarchy, metadata);
    tree.save(callback);
};




