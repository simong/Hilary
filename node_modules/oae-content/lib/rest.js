/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var log = require('oae-logger').logger('content-rest');
var OAE = require('oae-util/lib/oae');
var OaeUtil = require('oae-util/lib/util');

var ContentAPI = require('./api');
var ContentConstants = require('./constants').ContentConstants;

/**
 * Verify the signature information provided by a signed download request and
 * pass it on to the download handler to complete the download request
 *
 * @param  {Request}     req    The Express Request object
 * @param  {Response}    res    The Express Response object
 * @api private
 */
var _handleSignedDownload = function(req, res) {
    ContentAPI.verifySignedDownloadQueryString(req.ctx, req.query, function(err, downloadInfo) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        return _handleDownload(res, downloadInfo, true);
    });
};

/**
 * @REST postContentCreate
 *
 * Create a new piece of content
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/create
 * @FormParam   {string}            description         Description of content item
 * @FormParam   {string}            displayName         Name to display for content item
 * @FormParam   {string}            link                URL for link content
 * @FormParam   {string[]}          manager             Unique identifier(s) for manager(s) of the content (user creating discussion is always a manager)
 * @FormParam   {string[]}          viewer              Unique identifiers(s) for users(s) who can access the content
 * @FormParam   {string}            resourceSubType     Content type                        [collabdoc,file,link]
 * @FormParam   {string}            visibility          Visibility for content              [loggedin,private,public]
 * @FormParam   {File}              file                Binary contents of file for file content
 * @Return      {Content}                               The created content object
 */
OAE.tenantRouter.on('post', '/api/content/create', function(req, res) {
    // Ensure proper arrays for the additional members
    req.body.managers = OaeUtil.toArray(req.body.managers);
    req.body.viewers = OaeUtil.toArray(req.body.viewers);

    // Construct a hash for additional members that maps each user to their role
    var additionalMembers = {};
    _.each(req.body.managers, function(userId) {
        additionalMembers[userId] = ContentConstants.roles.MANAGER;
    });
    _.each(req.body.viewers, function(userId) {
        additionalMembers[userId] = ContentConstants.roles.VIEWER;
    });

    // Link creation
    if (req.body.resourceSubType === 'link') {
        ContentAPI.createLink(req.ctx, req.body.displayName, req.body.description, req.body.visibility, req.body.link, additionalMembers, function(err, contentObj) {
            if (err) {
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // File creation
    } else if (req.body.resourceSubType === 'file') {
        var uploadedFile = null;
        if (req.files) {
            uploadedFile = req.files.file;
        }
        ContentAPI.createFile(req.ctx, req.body.displayName, req.body.description, req.body.visibility, additionalMembers, uploadedFile, function(err, contentObj) {
            if (err) {
                // At this point we can use regular responses again.
                return res.send(err.code, err.msg);
            }
            // Set the response type to text/plain, as the UI uses an iFrame upload mechanism to support IE9
            // file uploads. If the response type is not set to text/plain, IE9 will try to download the response.
            res.set('Content-Type', 'text/plain');
            res.send(201, contentObj);
        });
    // Collaborative document creation
    } else if (req.body.resourceSubType === 'collabdoc') {
        ContentAPI.createCollabDoc(req.ctx, req.body.displayName, req.body.description, req.body.visibility, additionalMembers, function(err, contentObj) {
            if (err) {
                return res.send(err.code, err.msg);
            }
            res.send(201, contentObj);
        });
    // Not a recognized file type
    } else {
        res.send(400, 'Unrecognized resourceSubType. Accepted values are "link", "file" and "collabdoc"');
    }
});

/**
 * @REST deleteContentContentId
 *
 * Delete a piece of content
 *
 * @Server      tenant
 * @Method      DELETE
 * @Path        /content/{contentId}
 * @PathParam   {string}                contentId           Unique identifier for content to delete
 */
OAE.tenantRouter.on('delete', '/api/content/:contentId', function(req, res) {
    ContentAPI.deleteContent(req.ctx, req.params.contentId, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/**
 * @REST getContentContentId
 *
 * Get a full content profile for a piece of content
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}
 * @PathParam   {string}                contentId           Unique identifier for content
 * @Return      {ContentProfile}                            The full content profile
 */
OAE.tenantRouter.on('get', '/api/content/:contentId', function(req, res) {
    ContentAPI.getFullContentProfile(req.ctx, req.params.contentId, function(err, contentProfile) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, contentProfile);
    });
});

/**
 * @REST postContentContentId
 *
 * Edit content metadata
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}
 * @PathParam   {string}                contentId           Unique identifier for content to update
 * @FormParam   {string}                [description]       Description of content item
 * @FormParam   {string}                [displayName]       Name to display for content item
 * @FormParam   {string}                [link]              URL for link content
 * @FormParam   {string}                [visibility]        Visibility for content          [loggedin,private,public]
 * @Return      {Content}                                   The updated content
 */
OAE.tenantRouter.on('post', '/api/content/:contentId', function(req, res) {
    ContentAPI.updateContentMetadata(req.ctx, req.params.contentId, req.body, function(err, newContentObj) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, newContentObj);
    });
});

/**
 * @REST getContentContentIdDownload
 *
 * Download the latest version of a piece of content
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/download
 * @PathParam   {string}                contentId           Unique identifier for content to download
 * @Return      {File}                                      The content object
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/download', function(req, res) {
    ContentAPI.getRevisionDownloadInfo(req.ctx, req.params.contentId, null, function(err, downloadInfo) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        return _handleDownload(res, downloadInfo, false);
    });
});

/**
 * @REST getContentContentIdDownloadRevisionId
 *
 * Download a specific version of a piece of content
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/download/{revisionId}
 * @PathParam   {string}                contentId           Unique identifier for content to download
 * @PathParam   {string}                revisionId          Unique identifier for content revision
 * @Return      {File}                                      The content object
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/download/:revisionId', function(req, res) {
    ContentAPI.getRevisionDownloadInfo(req.ctx, req.params.contentId, req.params.revisionId, function(err, downloadInfo) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        return _handleDownload(res, downloadInfo, true);
    });
});

/**
 * @REST postContentContentIdNewversion
 *
 * Upload a new version of a file
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/newversion
 * @PathParam   {string}             contentId              Unique identifier for content to update
 * @FormParam   {File}               file                   Binary contents of file
 * @Return      {Content}                                   The content object
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/newversion', function(req, res) {
    if (!req.files || !req.files.file) {
        return res.send(400, 'Missing file parameter');
    }

    ContentAPI.updateFileBody(req.ctx, req.params.contentId, req.files.file, function(err, updatedContentObj) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        // Set the response type to text/plain, as the UI uses an iFrame upload mechanism to support IE9
        // file uploads. If the response type is not set to text/plain, IE9 will try to download the response.
        res.set('Content-Type', 'text/plain');
        res.send(200, updatedContentObj);
    });
});

/**
 * @REST postContentContentIdJoin
 *
 * Join a collaborative document
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/join
 * @PathParam   {string}             contentId              Unique identifier for collaborative document to join
 * @Return      {CollabDoc}                                 The collaborative document object
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/join', function(req, res) {
    ContentAPI.joinCollabDoc(req.ctx, req.params.contentId, function(err, data) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, data);
    });
});

/**
 * @REST postContentContentIdRevisionsRevisionIdPreviews
 *
 * Attach a preview item to a piece of content
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/revisions/{revisionId}/previews
 * @PathParam   {string}             contentId              Unique identifier for content
 * @PathParam   {string}             revisionId             Unique identifier for content revision
 * @FormParam   {UpdatedContent}     contentMetadata        Updated information about content
 * @FormParam   {PreviewLink}        links                  External link to use as preview image
 * @FormParam   {UpdatedPreview}     previewMetadata        Updated information about preview
 * @FormParam   {PreviewSize}        sizes                  Size of preview image
 * @FormParam   {File}               file                   Binary contents of preview image file
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/revisions/:revisionId/previews', function(req, res) {
    var contentMetadata = null;
    var previewMetadata = null;
    var sizes = null;
    var files = null;
    try {
        contentMetadata = JSON.parse(req.body.contentMetadata);
        previewMetadata = JSON.parse(req.body.previewMetadata);
        sizes = JSON.parse(req.body.sizes);

        if (req.body.links) {
            files = JSON.parse(req.body.links);
        }
    } catch (err) {
        var invalidField = null;
        if (!contentMetadata) {
            invalidField = 'contentMetadata';
        } else if (!previewMetadata) {
            invalidField = 'previewMetadata';
        } else if (!sizes) {
            invalidField = 'sizes';
        } else if (!files) {
            invalidField = 'links';
        }

        return res.send(400, 'Malformed metadata object. Expected proper JSON for: ' + invalidField);
    }

    if (req.files) {
        files = files || {};
        _.extend(files, req.files);
    }

    ContentAPI.setPreviewItems(req.ctx, req.params.contentId, req.params.revisionId, req.body.status, files, sizes, contentMetadata, previewMetadata, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(201);
    });
});

/**
 * @REST getContentContentIdRevisionsRevisionIdPreviews
 *
 * Get a list of preview items for the latest revision
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/revisions/{revisionId}/previews
 * @PathParam   {string}             contentId              Unique identifier for content
 * @PathParam   {string}             revisionId             Unique identifier for content revision
 * @Return      {PreviewList}                               Preview information for the content item
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId/previews', function(req, res) {
    ContentAPI.getPreviewItems(req.ctx, req.params.contentId, req.params.revisionId, function(err, previews) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        res.send(200, previews);
    });
});

/**
 * @REST getContentContentIdRevisionsRevisionIdPreviewsItem
 *
 * Download a preview item
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/revisions/{revisionId}/previews/{item}
 * @PathParam   {string}             contentId              Unique identifier for content
 * @PathParam   {string}             item                   Unique identifier for preview item
 * @PathParam   {string}             revisionId             Unique identifier for content revision
 * @QueryParam  {string}             expires                Expiration time for credentials
 * @QueryParam  {string}             lastmodified           Last modification time for content
 * @QueryParam  {string}             signature              Credentials to access content
 * @Return      {File}                                      The preview item object
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId/previews/:item', function(req, res) {
    var signature = {
        'signature': req.query.signature,
        'expires': req.query.expires,
        'lastModified': req.query.lastmodified
    };
    ContentAPI.getSignedPreviewDownloadInfo(req.ctx, req.params.contentId, req.params.revisionId, req.params.item, signature, function(err, downloadInfo) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        return _handleDownload(res, downloadInfo, true);
    });
});

/**
 * @REST getContentContentIdRevisions
 *
 * Get content revisions
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/revisions
 * @PathParam   {string}            contentId           Unique identifier for content
 * @QueryParam  {number}            [limit]             Maximum number of revisions to return (defaults to 10, maximum of 25)
 * @QueryParam  {number}            [start]             Revision at which to start (defaults to 0)
 * @Return      {RevisionsResponse}                     Revisions information
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getRevisions(req.ctx, req.params.contentId, req.query.start, limit, function(err, revisions, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': revisions, 'nextToken': nextToken});
    });
});

/**
 * @REST getContentContentIdRevisionsRevisionId
 *
 * Get a specific content revision
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/revisions/{revisionId}
 * @PathParam   {string}            contentId           Unique identifier for content
 * @PathParam   {string}            revisionId          Unique identifier for content revision
 * @Return      {Revision}                              Revision information
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/revisions/:revisionId', function(req, res) {
    ContentAPI.getRevision(req.ctx, req.params.contentId, req.params.revisionId, function(err, revision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, revision);
    });
});

/**
 * @REST postContentContentIdRevisionsRevisionIdRestore
 *
 * Restore a specific content revision
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/revisions/{revisionId}/restore
 * @PathParam   {string}            contentId           Unique identifier for content
 * @PathParam   {string}            revisionId          Unique identifier for content revision
 * @Return      {Revision}                              New revision information
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/revisions/:revisionId/restore', function(req, res) {
    ContentAPI.restoreRevision(req.ctx, req.params.contentId, req.params.revisionId, function(err, newRevision) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, newRevision);
    });
});

/**
 * @REST getContentContentIdMembers
 *
 * Get content membership list
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/members
 * @PathParam   {string}            contentId           Unique identifier for content
 * @QueryParam  {number}            [limit]             Maximum number of members to return (defaults to 10, maximum of 25)
 * @QueryParam  {number}            [start]             Member at which to start (defaults to 0)
 * @Return      {MembersResponse}                       Member information
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/members', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getContentMembersLibrary(req.ctx, req.params.contentId, req.query.start, limit, function(err, members, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': members, 'nextToken': nextToken});
    });
});

/**
 * @REST postContentContentIdMembers
 *
 * Set content permission
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/members
 * @PathParam   {string}        contentId           Unique identifier for content
 * @FormParam   {string}        {userId}            Permission for specified user, may be repeated for multiple users [false,manager,viewer]
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/members', function(req, res) {
    // Parse the incoming false values
    var requestKeys = _.keys(req.body);
    for (var r = 0; r < requestKeys.length; r++) {
        req.body[requestKeys[r]] = OaeUtil.castToBoolean(req.body[requestKeys[r]]);
    }
    ContentAPI.setContentPermissions(req.ctx, req.params.contentId, req.body, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/**
 * @REST postContentContentIdShare
 *
 * Share content
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/share
 * @PathParam   {string}        contentId           Unique identifier for content
 * @FormParam   {string[]}      viewers             Users with whom to share content
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/share', function(req, res) {
    // Make sure viewers is an array
    req.body.viewers = OaeUtil.toArray(req.body.viewers);
    ContentAPI.shareContent(req.ctx, req.params.contentId, req.body.viewers, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/**
 * @REST postContentContentIdMessages
 *
 * Add a comment to a piece of content
 *
 * @Server      tenant
 * @Method      POST
 * @Path        /content/{contentId}/messages
 * @PathParam   {string}        contentId           Unique identifier for content
 * @FormParam   {string}        body                Content of new message
 * @FormParam   {string}        [replyTo]           Created time for message to which the new message is a reply
 */
OAE.tenantRouter.on('post', '/api/content/:contentId/messages', function(req, res) {
    ContentAPI.createComment(req.ctx, req.params.contentId, req.body.body, req.body.replyTo, function(err, message) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(201, message);
    });
});

/**
 * @REST getContentContentIdMessages
 *
 * List the comments on a piece of content
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/{contentId}/messages
 * @PathParam   {string}            contentId           Unique identifier for content
 * @QueryParam  {number}            [limit]             Maximum number of messages to return (defaults to 10, maximum of 25)
 * @QueryParam  {number}            [start]             Message at which to start (defaults to 0)
 * @Return      {MessagesResponse}                      List of comments for content
 */
OAE.tenantRouter.on('get', '/api/content/:contentId/messages', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 10, 1, 25);
    ContentAPI.getComments(req.ctx, req.params.contentId, req.query.start, limit, function(err, messages, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': messages, 'nextToken': nextToken});
    });
});

/**
 * @REST deleteContentContentIdMessagesCreated
 *
 * Delete a comment on a piece of content
 *
 * @Server      tenant
 * @Method      DELETE
 * @Path        /content/{contentId}/messages/{created}
 * @PathParam   {string}                created             Creation time of message to delete
 * @PathParam   {string}                contentId           Unique identifier for content containing message
 * @Return      {Message}                                   The deleted message
 */
OAE.tenantRouter.on('delete', '/api/content/:contentId/messages/:created', function(req, res) {
    ContentAPI.deleteComment(req.ctx, req.params.contentId, req.params.created, function(err, deleted) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, deleted);
    });
});

/**
 * @REST getContentLibraryPrincipalId
 *
 * List a principal's library
 *
 * @Server      tenant
 * @Method      GET
 * @Path        /content/library/{principalId}
 * @PathParam   {string}        principalId         Unique identifier for user/group/etc.
 * @QueryParam  {number}        [limit]             Maximum number of messages to return (defaults to 12, maximum of 25)
 * @QueryParam  {number}        [start]             Message at which to start (defaults to 0)
 * @Return      {ItemsResponse}                     List of items in library
 */
OAE.tenantRouter.on('get', '/api/content/library/:principalId', function(req, res) {
    var limit = OaeUtil.getNumberParam(req.query.limit, 12, 1, 25);
    ContentAPI.getContentLibraryItems(req.ctx, req.params.principalId, req.query.start, limit, function(err, items, nextToken) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200, {'results': items, 'nextToken': nextToken});
    });
});

/**
 * @REST deleteContentContentIdMessagesCreated
 *
 * Delete a piece of content from a library
 *
 * @Server      tenant
 * @Method      DELETE
 * @Path        /content/library/{principalId}/{contentId}
 * @PathParam   {string}            created             Creation time of message to delete
 * @PathParam   {string}            contentId           Unique identifier for content containing message
 * @PathParam   {string}            principalId         Unique identifier for user/group/etc.
 */
OAE.tenantRouter.on('delete', '/api/content/library/:principalId/:contentId', function(req, res) {
    ContentAPI.removeContentFromLibrary(req.ctx, req.params.principalId, req.params.contentId, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }
        res.send(200);
    });
});

/**
 * @REST getDownloadSigned
 *
 * Download a content item
 *
 * @Server      admin,tenant
 * @Method      GET
 * @Path        /download/signed
 * @QueryParam  {number}        [expires]           Expiration time for signature (epoch format)
 * @QueryParam  {string}        signature           Signature for content
 * @Return      {File}                              The content item
 */
OAE.globalAdminRouter.on('get', '/api/download/signed', _handleSignedDownload);
OAE.tenantRouter.on('get', '/api/download/signed', _handleSignedDownload);

/**
 * Send the correct HTTP response according to a download strategy. Note that the "direct" download strategy is not being handled here
 * as the direct strategy should not be requested to the application for action, instead its target is delivered to the user verbatim
 * with no signature.
 *
 * @param  {Response}           res                     The Express Response object
 * @param  {Object}             downloadInfo            An object that represents an item that can be downloaded from the application
 * @param  {String}             downloadInfo.filename   The file name of the download
 * @param  {DownloadStrategy}   downloadInfo.strategy   How the application should deliver the download
 * @param  {Boolean}            [expiresMax]            Whether a far future expires response header should be set
 * @api private
 */
var _handleDownload = function(res, downloadInfo, expiresMax) {
    var downloadStrategy = downloadInfo.strategy;

    // A 204 suggest that the LB (nginx, apache, lighthttpd, ..) will be handling the download via the x-sendfile mechanisme.
    if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_INTERNAL) {
        // Nginx internal download
        res.setHeader('X-Accel-Redirect', downloadStrategy.target);

        // Apache internal download
        res.setHeader('X-Sendfile', downloadStrategy.target);

        // Lighthttpd internal download
        res.setHeader('X-LIGHTTPD-send-file', downloadStrategy.target);

        if (expiresMax) {
            // Add the cache headers manually as some webservers are not
            // able to deal with setting cache headers and internal redirects
            // @see https://github.com/oaeproject/Hilary/issues/995
            res.setHeader('Expires', 'Thu, 31 Dec 2037 23:55:55 GMT');
            res.setHeader('Cache-Control', 'max-age=315360000');
        }

        res.setHeader('Content-Disposition', 'attachment; filename="' + downloadInfo.filename + '"');
        res.send(204, downloadStrategy.target);

    // A redirect strategy will invoke a redirect to the target
    } else if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_REDIRECT) {
        // We can't guarantee that the backend won't want to update some details about the target over time. e.g., update some tracking
        // variables over time for analytics or additional security. Therefore, we do a temporary redirect (302)
        res.setHeader('Location', downloadStrategy.target);
        res.send(302);

    // The app server will send the file to the client. This should *NOT* be used in production and is only really here for easier unit
    // testing purposes
    } else if (downloadStrategy.strategy === ContentConstants.backend.DOWNLOAD_STRATEGY_TEST) {
        return res.download(downloadStrategy.target);

    // In all other cases we respond with a 404
    } else {
        res.send(404);
    }
};
