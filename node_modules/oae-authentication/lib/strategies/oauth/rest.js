/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var BasicStrategy = require('passport-http').BasicStrategy;
var ClientPasswordStrategy = require('passport-oauth2-client-password').Strategy;
var oauth2orize = require('oauth2orize');
var passport = require('passport');

var log = require('oae-logger').logger('oae-authentication');
var OAE = require('oae-util/lib/oae');
var OaeServer = require('oae-util/lib/server');

var OAuthDAO = require('./internal/dao');
var OAuthAPI = require('./api');


/////////////////
// OAuth setup //
/////////////////

// The OAuth instance that will take care of creating authorization codes and access tokens
var server = oauth2orize.createServer();

server.serializeClient(function(client, callback) {
    return callback(null, client.id);
});

server.deserializeClient(function(id, callback) {
    OAuthDAO.Clients.getClientById(id, function(err, client) {
        if (err) {
            return callback(err);
        }

        return callback(null, client);
    });
});

//////////////////////////////
// Client Credentials Grant //
//////////////////////////////

/*!
 * The following exchange is called the "Client Credentials Grant". In it, a client
 * exchanges its id and secret for an access token. Typically this is only used to update
 * the client's information. However, within OAE all API requests need to be either anonymous
 * or authenticated as a user. We deviate from the specification slightly and will bind each
 * client to a user. When a client requests an access token via the Client Credentials Grant,
 * we will grant an access token for the user who "owns" the client.
 *
 * By the time this method gets called, the client credentials have already been validated
 * and we can simply return an "Access Token".
 *
 * @param  {Client}         client              The client who desires an access token
 * @param  {[type]}         [scope]             The scope of access requested by the client. This is unused within OAE
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object, if any
 * @param  {AccessToken}    callback.token      An access token that can be used to interact with the OAE apis as a user
 */
server.exchange(oauth2orize.exchange.clientCredentials(function(client, scope, callback) {
    // In theory, each client should cache their access token, but that's probably a pipedream
    // We should check if this client has a token already so we don't generate a new one each time
    OAuthDAO.AccessTokens.getAccessTokenForUserAndClient(client.userId, client.id, function(err, accessToken) {
        if (err) {
            return callback(err);

        // This client has a token, return it
        } else if (accessToken) {
            return callback(null, accessToken.token);
        }

        // This is the first time this client is requesting a token, we'll need to generate one
        var token = OAuthAPI.generateToken(256);
        OAuthDAO.AccessTokens.createAccessToken(token, client.userId, client.id, function(err) {
            if (err) {
                return callback(err);
            }

            // Return an access token to the client
            log().info({'client': client.id, 'user': client.userId}, 'An access token has been handed out via Client Credentials');
            return callback(null, token);
        });
    });
}));


/////////////////////////
// Regular OAuth grant //
/////////////////////////

/*!
 * When the user has accepted that the client can access OAE resources on his behalf,
 * the client will be granted an authorization code. The next bit of code is responsible
 * for generating such a code and persisting it too the database.
 *
 * @param  {Client}             client          The client who is asking to interact with the API on `user` his behalf
 * @param  {String}             redirectURI     The URL where the user should be redirected to when he grants access to the client
 * @param  {User}               user            The user who is granting access
 * @param  {Object}             [ares]          Any additional parameters parsed from the user's decision, including scope, duration of access, etc. This has not been implemented yet
 * @param  {Function}           callback        Standard callback function
 * @param  {Object}             callback.err    Error object, if any
 * @param  {AuthorizationCode}  callback.code   An authorization code that allows the client to request an access token for this user
 * @api private
 */
server.grant(oauth2orize.grant.code(function(client, redirectURI, user, ares, callback) {
    var code = OAuthAPI.generateToken(16);
    OAuthDAO.AuthorizationCodes.createAuthorizationCode(code, user.id, client.id, redirectURI, function(err) {
        if (err) {
            return callback(err);
        }

        log().info({'client': client.id, 'user': user.id, 'redirectURI': redirectURI, 'code': code}, 'An authorization token has been handed out');
        return callback(null, code);
    });
}));

/**
 * The following exchange is called the "Authorization code grant". In it, a client
 * exchanges an authorization code that he obtained previously, for an access token.
 * This is used when a client redirects a user to OAE where the user can click an "Accept" button
 *
 * @param  {Client}                 client              The client who is asking for an access token
 * @param  {AuthorizationCode}      code                The authorization code the client wishes to exchange for an access token
 * @param  {String}                 redirectURI         The redirect URI that the client was sent too when the authorization code was granted. We should verify that this actually matches the authorization code we handed out
 * @param  {Function}               callback            Standard callback function
 * @param  {Object}                 callback.err        Error object, if any
 * @param  {AccessToken}            callback.token      An access token that can be used to interact with the OAE apis as a user
 * @api private
 */
server.exchange(oauth2orize.exchange.code(function(client, code, redirectURI, done) {
    console.log('exchange.code');
    console.log(arguments);
    OAuthDAO.AuthorizationCodes.getAuthorizationCode(code, function(err, authCode) {
        console.log('getAuthorizationCode');
        console.log(arguments);
        if (err) {
            return done(err); 

        // Ensure the authorization code exists
        } else if (!authCode) {
            return done(null, false);

        // Ensure that the client who is asking for the access token matches the client from the authorization code
        } else if (client.id !== authCode.clientId) {
            return done(null, false);

        // The spec dictates that if a redirect URI was provided in the authorization code,
        // the exact same URI needs to be provided in the access token request
        } else if (authCode.redirectUri && redirectURI !== authCode.redirectUri) {
            return done(null, false);
        }

        // Everything seems in order, we can now remove the authorization code so that it can't be re-used later if the user removes access to the client
        OAuthDAO.AuthorizationCodes.removeAuthorizationCode(code, function(err) {
            console.log('removeAuthorizationCode');
            console.log(arguments);
            if (err) {
                return done(err);
            }

            // We can now create an access token that the client can use
            var token = OAuthAPI.generateToken(256);

            // Persist the access token so we can verify it when people are using the API
            OAuthDAO.AccessTokens.createAccessToken(token, authCode.userId, authCode.clientId, function(err) {
                console.log('createAccessToken');
                console.log(arguments);
                if (err) {
                    return done(err);
                }

                // Hand the access token to the client
                log().info({'client': client.id, 'user': authCode.userId, 'redirectURI': redirectURI, 'code': code}, 'An authorization code has been exchanged for an access token');
                return done(null, token);
            });
        });
    });
}));

/*!
 * Initiate the "Authorization Code Grant" transaction.
 * This API endpoint should be consumed by the UI when a client wants
 * access to a user's resources. If the request is deemed valid,
 * a transaction ID will be returned that can be used to accept the authorization
 * request.
 *
 * Additionaly, the client metadata is returned so the UI can display a nice
 * message about which client is requesting access.
 */
OAE.tenantServer.get('/api/auth/oauth/v2/authorize', function(req, res, next) {
        // Ensure they are logged in
        if (req.ctx && !req.ctx.user()) {
            return res.send(401, 'Only authenticated users can request authorization');
        }

        return next();
    },
    server.authorization(function(clientID, redirectURI, done) {

        OAuthDAO.Clients.getClientById(clientID, function(err, client) {
            if (err) { return done(err); }
            // WARNING: For security purposes, it is highly advisable to check that
            //          redirectURI provided by the client matches one registered with
            //          the server.  For simplicity, this example does not.  You have
            //          been warned.
            return done(null, client, redirectURI);
        });
    }),
    function(req, res) {
        // Send the transaction ID back to the client
        // They will have to send it to the decision endpoint
        var client = req.oauth2.client;
        delete client.userId;
        delete client.secret;
        res.send(200, { 'transactionID': req.oauth2.transactionID, 'client': client });
    }
);

/*!
 * Can be used when a user grants the client access to their resources.
 * The transactionID that was provided in the `/api/auth/oauth/v2/authorize`
 * call, needs to be passed in here as a `transaction_id` parameter.
 */
OAE.tenantServer.post('/api/auth/oauth/v2/authorize/decision', function(req, res, next) {
        // Ensure logged in
        if (req.ctx && !req.ctx.user()) {
            return res.send(401, 'Only authenticated users can request authorization');
        }

        return next();
    }, server.decision()
);

//////////////////
// Access Token //
//////////////////

/**
 * Verifies that the passed in client ID and secret are correct
 *
 * @param  {String}     clientId            The ID of the client to check
 * @param  {String}     clientSecret        The secret to check
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Standard error object
 * @param  {Client}     callback.client     The authenticated client
 * @api private
 */
var verifyClientAuthentication = function(clientId, clientSecret, callback) {
    OAuthDAO.Clients.getClientById(clientId, function(err, client) {
        if (err) {
            return callback(err);
        } else if (!client) {
            return callback(null, false);
        } else if (client.secret != clientSecret) {
            log().warn({'client': client.id}, 'A client attempted to authenticate with the wrong secret');
            return callback(null, false);
        }

        return callback(null, client);
    });
};

/*!
 * BasicStrategy & ClientPasswordStrategy
 *
 * These strategies are used to authenticate registered OAuth clients.  They are
 * employed to protect the `token` endpoint, which consumers use to obtain
 * access tokens.  The OAuth 2.0 specification suggests that clients use the
 * HTTP Basic scheme to authenticate.  Use of the client password strategy
 * allows clients to send the same credentials in the request body (as opposed
 * to the `Authorization` header).  While this approach is not recommended by
 * the specification, in practice it is quite common.
 */
passport.use(new BasicStrategy(verifyClientAuthentication));
passport.use(new ClientPasswordStrategy(verifyClientAuthentication));

/*!
 * This endpoint is used by clients to obtain an access token.
 * Either by exchanging an authorization token for an access token,
 * or by using the "Client Credentials Grant".
 */
OAE.tenantRouter.on('post', '/api/auth/oauth/v2/token',
    [
        // OAuth allows for 2 possible strategies to authenticate an "Access Token Request" HTTP request
        passport.authenticate(['basic', 'oauth2-client-password'], { 'session': false }),
        
        // If authentication was succesful, hand out a token
        server.token(),

        // Take care of any errors that were triggered by the token handler
        server.errorHandler()
    ]
);

/*
 * At this point, the client will not be authenticated yet, so we need
 * to add the CSRF exception
 */
OaeServer.addSafePathPrefix('/api/auth/oauth/v2/token');


//////////////////////
// Client endpoints //
//////////////////////

/*!
 * Create a client for a user
 */
OAE.tenantRouter.on('post', '/api/auth/oauth/clients/:userId', function(req, res) {
    OAuthAPI.Clients.createClient(req.ctx, req.params.userId, req.body.displayName, function(err, client) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        res.send(201, client);
    });
});

/*!
 * Get all the clients for a user
 */
OAE.tenantRouter.on('get', '/api/auth/oauth/clients/:userId', function(req, res) {
    OAuthAPI.Clients.getClients(req.ctx, req.params.userId, function(err, clients) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        res.send(200, {'results': clients});
    });
});

/*!
 * Update a client for a user
 */
OAE.tenantRouter.on('post', '/api/auth/oauth/clients/:userId/:clientId', function(req, res) {
    OAuthAPI.Clients.updateClient(req.ctx, req.params.clientId, req.body.displayName, req.body.secret, function(err, client) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        res.send(200, client);
    });
});

/*!
 * Delete a client for a user
 */
OAE.tenantRouter.on('del', '/api/auth/oauth/clients/:userId/:clientId', function(req, res) {
    OAuthAPI.Clients.deleteClient(req.ctx, req.params.clientId, function(err) {
        if (err) {
            return res.send(err.code, err.msg);
        }

        res.send(200);
    });
});
